$OldWord = "742.docx"
$folderPath = "C:\Codeprojects\ParseWordDocument\"
$mediaFolder = "C:\Codeprojects\ParseWordDocument\docx\word\media\"
$imageFolder = $folderPath + "images\"
$Outputformat = "CSV" # Enter 'CSV' or 'Word' if you would like CSV or DOCX output format
$examNumber = "70-742"
$CSVFormat = "QuestionType;Question;Description;correct option number;Option 1;Option 2;Option 3;Option 4;Option 5;Option 6;Option 7;Option 8;Option 9;Option 10;Option 11;Option 12;"
$imageURLPrefix = "https://files.doorhetgeluid.nl/images/70-742/"

$reg = '([A-Z]{1})[\.](.*)' # Regex match string to select First letter in Option, replace '.' with ':)', finally add answer.
$Selector = New-Object psobject -Property @{
  question = "QUESTION*"
  ;explanation = "Explanation*"
  ;correct = "Correct Answer*"
  ;section = "Section*"
  ;options = @(
    "A.*"
    ,"B.*"
    ,"C.*"
    ,"D.*"
    ,"E.*"
    ,"F.*"
    ,"G.*"
    ,"H.*"
  )
  ;imageFormat = @(
    "*.jpeg"
    ,"*.png"
  )
  ;filter = @(
    "*gratisexam*"
  )
} # End of Selector object


$jsonExamTemplate = New-Object psobject -Property @{
  id = [int] # exam ID
  ;title = [string] # exam title
  ;description = [string] # exam description
  ;author = @{
    id = [int] # author ID
    ;name = [string] # author name
    ;image = [string] # author image
  }
  ;code = [string] # exam code
  ;time = [int] # exam time
  ;pass = [int] # minimum exam score needed
  ;image = [string] # exam cover image
  ;cover = @() # takes objects generated by variant function
  ;test = @() # takes objects generated by question function
}

function newJsonQuestion () {
  New-Object psobject -Property @{
    variant = [int] # question variant
    ;question = @() # body of actual question
    ;choices = @() # body of actual choices
    ;answer = @() # array with true/false for every choice
    ;explanation = @() # explanation
  }
}





# install PSWriteWord module to easier edit word document: "install-module -name PSWriteWord -Force"
Import-Module PSWriteWord -Force

# Functions
function NewQuestion (){ # Create new question object
  $propertylist = [ordered] @{
    index = [string]
    ;section = @()
    ;type = @()
    ;text = @()
    ;image = @()
    ;answers = @()
    ;correct = @()
    ;explanation = @()
  }
  $question = New-Object psobject -Property $propertylist
  $question
} # End of function NewQuestion

function Like ( $str, $patterns ) { # Perform like search in Array
  $patterns | ForEach-Object {
    if ($str -ilike $_ ) {
      return $true
    }
  }  
} # End of function Like

function ConvertAnswer($_) {
  $input = $_.tostring()
  switch ( $input ) {
    "A" {"1"; Break}
    "B" {"2"; break}
    "C" {"3"; break}
    "D" {"4"; break}
    "E" {"5"; break}
    "F" {"6"; break}
    "G" {"7"; break}
    "H" {"8"; break}
    "I" {"9"; break}
    "J" {"10"; break}
    "K" {"11"; break}
    "L" {"12"; break}
  }
} # End of function ConvertAnswer

$OldWordDocument = Get-WordDocument -FilePath ($folderPath + $OldWord)
$paragraphs = $OldWordDocument.Paragraphs

# Create Image folder (for exported images) in working directory, if it not already exists
 if ( (Test-Path -Path ($imageFolder)) -like "False" ) {
   New-Item -Path $folderPath -Name "images" -ItemType Directory
 }


############### Store all the Question parts per Question in Objects, store Objects in $QuestionArray ###############


######################## Process buffer to CSV ########################
elseif ($Outputformat -like "CSV") {

### Process Paragraphs and store them in $Buffer, store content per question in array in $Buffer ###
# Access like this: "$buffer[questionnumber][indexnumberofcontentinquestion]""
$QuestionArray = @()
$questid = 0
$QuestionArray += NewQuestion
$textExplanation = $false

for ( $i=0; $i -lt $paragraphs.count; $i++ ) {
  # write-host "starting round $($i)" # Turn on for Debugging

  if ( !(Like $paragraphs[$i].text $Selector.question) ) { # If NOT start of new question, continue
    
    if ( ($paragraphs[$i].Pictures).count -like 1 ) # Images
    { 
      $QuestionArray[$questid].image += $imageURLPrefix + $paragraphs[$i].Pictures.FileName
      Copy-Item -Path ($mediaFolder + $paragraphs[$i].Pictures.FileName) -Destination ($imageFolder + $paragraphs[$i].Pictures.FileName) -ErrorAction Ignore # Copy image to export folder for upload to server
    }
    elseif ($paragraphs[$i].text -like $Selector.filter ) # Filter unwanted text
    { 
      # skip it
    }  
    elseif ($paragraphs[$i].text -like $Selector.section ) # Section description of exam
    { 
        $QuestionArray[$questid].section += $paragraphs[$i].text
    } 
    elseif ( $paragraphs[$i].islistitem ) # Possible answers
    { 
        $QuestionArray[$questid].answers += $paragraphs[$i].text
    }
    elseif ( $paragraphs[$i].text -like $Selector.correct ) # Correct answer
    {
        $QuestionArray[$questid].correct += ($paragraphs[$i].text).replace("Correct Answer: ","")
    }
    elseif ( $textExplanation ) # Add to Explanation Array
    {
        $QuestionArray[$questid].explanation += $paragraphs[$i].text
    }
    elseif ($paragraphs[$i].text -like $Selector.explanation ) # Add to explanation property
    {
        $QuestionArray[$questid].explanation += $paragraphs[$i].text
        $textExplanation = $true # Ensures all in-question-buffer is stored in Explanation array.
    }
    else # The question itself
    { 
      $QuestionArray[$questid].text += $paragraphs[$i].text
    }
  }
  elseif ( (Like $paragraphs[$i].text $Selector.question) ) { # New question starts, reset everything

    if ($QuestionArray[$questid].correct[0].Length -like 1){
        $QuestionArray[$questid].type = "single_answer"
    }
    elseif ($QuestionArray[$questid].correct[0].Length -gt 1){
        $QuestionArray[$questid].type = "multiple_answers"
    }

    $QuestionArray[$questid].index = $questid
    $QuestionArray += NewQuestion
    $textExplanation = $false
    $questid ++
  } 
} # End for loop





  # Save Data as JSON
  $QuestionArray | ConvertTo-Json | Out-File -FilePath ($folderPath + "new-$($examNumber).json")

} # End of Process Buffer to CSV




